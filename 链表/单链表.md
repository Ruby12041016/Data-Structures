1. 单链表是一种链式存储结构，每个节点包含数据域和指针域，指针域指向下一个节点，整个链表通过头指针访问。

2. 单链表的节点在物理上可以离散分布，不需要连续的大块内存，便于动态扩展，但不支持随机访问，只能从头开始遍历查找。 

3. 单链表分为带头节点和不带头节点两种形式，带头节点的链表在操作统一性和代码简洁性方面更具优势。 

4. 初始化不带头节点的单链表只需将头指针置为空（NULL），带头节点的链表要为头节点分配空间，并将其指针域置为空。  

5. 判断不带头节点的单链表是否为空依据是头指针是否为NULL，带头节点的链表判断头节点的next是否为NULL。 

8. 单链表的查找操作分为按位查找和按值查找，其中按位查找是通过传入位置I返回对应节点，代码实现时要考虑I小于0或大于链表长度等边界情况，该操作的时间复杂度为O(n)，且带头节点的单链表将头节点视为第0个节点。

11. 按位插入可以通过先调用按位查找获取前驱节点，再在其后执行后插操作。

12. 按值查找是从第一个数据节点开始依次比较每个节点的数据域是否等于目标值，若相等则返回该节点，否则继续向后移动直到p为null。

13. 求单链表长度是让p指针从头到尾依次扫描，同时用计数器累加节点数量，最后返回总数，其时间复杂度也为O(n)。

14. 尾插法建表是每次将新元素插入表尾，可用按位序插入实现，但会导致每次都要从头遍历找最后一个节点，总时间复杂度为O(n²)。优化方法是设置一个始终指向表尾的指针r，直接在r后进行后插操作

16. 头插法建表是每次将新元素插入头节点之后，就是对头节点执行后插操作，每插入一个元素都形成新的第一个节点，最终链表中元素顺序与输入顺序相反。

18. 初始化头节点时必须将其next指针显式置为null，否则动态分配的内存可能包含脏数据导致指针指向未知区域，引发严重错误。无论头插法还是尾插法要先初始化指针。