

### 树（Tree）

树是由节点和边组成的非线性数据结构，其中一个节点被称为根节点，其他节点通过边与根节点连接。

#### 1. 树的基本概念

* **根节点（Root Node）**：树的最顶层节点，所有其他节点都是从根节点分支出来的。
* **节点（Node）**：树中的元素。每个节点通常包含数据和指向其子节点的引用或指针。
* **边（Edge）**：连接树中两个节点的关系。
* **叶子节点（Leaf Node）**：没有子节点的节点，通常位于树的最底层。
* **内部节点（Internal Node）**：有子节点的节点。
* **父节点（Parent Node）**：每个节点的直接上级节点。
* **子节点（Child Node）**：由某个节点直接连接的节点。
* **兄弟节点（Sibling Node）**：具有相同父节点的节点。
* **高度（Height）**：从该节点到叶子节点的最长路径上的边数。根节点的高度是树的高度。
* **层（Level）**：节点的深度。根节点在第 0 层，它的子节点在第 1 层，依此类推。
* **度（Degree）**：节点的子节点数目。

#### 2. 树的类型

* **二叉树（Binary Tree）**：每个节点最多有两个子节点，通常称为左子节点和右子节点。常用于实现堆、二叉查找树等。

  * **完全二叉树（Complete Binary Tree）**：除了最后一层，其他所有层的节点都已满，且最后一层的节点从左到右填充。
  * **满二叉树（Full Binary Tree）**：每个节点都有两个子节点，且所有叶子节点都在同一层。
  * **平衡二叉树（Balanced Binary Tree）**：左右子树的高度差不超过 1 的二叉树。例如 AVL 树和红黑树。

* **二叉查找树（Binary Search Tree, BST）**：是一种特定类型的二叉树，对于每个节点，左子树的所有节点的值都小于节点值，右子树的所有节点值都大于节点值。

  * **AVL 树**：是一种自平衡的二叉查找树，每次插入或删除节点时，都会通过旋转操作保持树的平衡，保证树的高度为 O(log n)。
  * **红黑树（Red-Black Tree）**：一种自平衡的二叉查找树，通过规定节点颜色并进行相应的调整，确保树的高度始终保持在 O(log n) 级别。

* **B 树（B-tree）**：一种多路平衡查找树，节点包含多个子节点，常用于数据库和文件系统中，以提高查询效率。B 树是一种**自平衡的**树，支持高效的插入、删除、查找等操作。

* **B+ 树**：是 B 树的一种变体，它将所有值存储在叶子节点中，非叶节点仅存储键值，通常用于数据库索引。

* **堆（Heap）**：堆是一种特殊的完全二叉树，通常用于实现优先队列。

  * **最大堆（Max Heap）**：每个节点的值大于或等于其子节点的值。
  * **最小堆（Min Heap）**：每个节点的值小于或等于其子节点的值。

* **Trie 树（字典树）**：一种树形结构，用于存储一组字符串，特别适用于查找和前缀匹配问题。

* **线段树（Segment Tree）**：一种树形结构，用于解决区间查询和区间修改的问题，广泛应用于区间相关问题的高效解决。

* **线索二叉树（Threaded Binary Tree）**：在普通的二叉树中，每个节点有两个指针：一个指向左子树，一个指向右子树。而在线索二叉树中，除了常规的左右子指针外，当某个节点的左子节点为空时，它的左指针会指向该节点的前驱节点；当右子节点为空时，它的右指针会指向该节点的后继节点。这些指针被称为 **线索**。
  * **前驱线索**：如果节点的左子节点为空，则左指针指向该节点的前驱节点（在中序遍历中的前一个节点）。
  * **后继线索**：如果节点的右子节点为空，则右指针指向该节点的后继节点（在中序遍历中的下一个节点）。

#### 3. 树的性质

* **树的节点数和边数**：一棵有 `n` 个节点的树，必然有 `n-1` 条边。
* **树的高度和深度**：树的高度是树中所有节点深度的最大值，而树的深度是从根节点到该节点的路径长度。
* **完全二叉树的节点数**：一棵完全二叉树的节点数是 `2^h - 1`，其中 `h` 是树的高度。

#### 4. 树的遍历方法

* **前序遍历（Preorder Traversal）**：访问根节点 → 访问左子树 → 访问右子树。
* **中序遍历（Inorder Traversal）**：访问左子树 → 访问根节点 → 访问右子树。
* **后序遍历（Postorder Traversal）**：访问左子树 → 访问右子树 → 访问根节点。
* **层次遍历（Level-order Traversal）**：从上到下逐层访问树的节点，通常使用队列来实现。

#### 5. 树的时间复杂度

树的操作（如查找、插入、删除等）的时间复杂度依赖于树的高度。假设树的高度为 `h`，节点数为 `n`：

| 操作            | 时间复杂度 |
| ------------- | ----- |
| 查找（Search）    | O(h)  |
| 插入（Insert）    | O(h)  |
| 删除（Delete）    | O(h)  |
| 遍历（Traversal） | O(n)  |

对于平衡树（如 AVL 树、红黑树），树的高度是对数级别的，因此查找、插入、删除的时间复杂度为 O(log n)。

#### 6. 树的空间复杂度

树的空间复杂度通常是 O(n)，其中 `n` 是树中的节点数。因为每个节点需要存储数据以及指向子节点的指针。对于二叉树来说，每个节点需要两个指针（左指针和右指针），所以空间复杂度为 O(n)。

#### 7. 树的优势与局限

* **优势**：

  * 适用于具有层次结构的数据表示，如文件系统、公司组织结构、计算机网络等。
  * 提供高效的查找、插入和删除操作，特别是平衡树。
  * 支持多种操作，能满足不同的应用需求。

* **局限**：

  * 对于不平衡的树，查找、插入、删除等操作可能会退化成线性时间复杂度（O(n)）。
  * 内存占用相对较高，特别是对于多路树（如 B 树、B+ 树等）。








