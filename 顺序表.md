1. 顺序表是用顺序存储方式实现的线性表，逻辑上相邻的数据元素在物理存储位置上也相邻，通过内存地址的连续性来体现数据元素之间的先后关系。

2. 顺序存储要求所有数据元素类型相同，每个元素占用的内存空间大小一致，因此可以通过起始地址和元素大小计算任意元素的存储位置，实现随机访问。
  
3. 静态分配的顺序表使用固定长度的数组实现，一旦定义后容量不可更改，优点是实现简单，缺点是容易造成内存浪费或空间不足。 

4. 动态分配的顺序表通过malloc函数申请连续内存空间，并使用指针指向首元素，支持在空间不足时重新申请更大空间并复制数据以扩展容量。 

5. 动态分配虽然解决了容量固定的问题，但扩容过程需要复制数据并释放原空间，时间开销较大，且需手动管理内存，使用free函数及时释放不再使用的空间。  

6. 顺序表具有随机访问特性，可在O(1)时间内根据下标访问任一元素，得益于元素在内存中的连续存放和等长特性。

7. 顺序表的存储密度高，每个节点仅存储数据元素本身，无需额外存储指向其他节点的指针信息。  

8. 顺序表插入和删除操作效率较低，需移动大量元素以保持物理上的连续性，平均和最坏时间复杂度均为O(n)。 

9. 插入操作需将目标位置及其后的元素依次后移一位，然后插入新元素并更新表长，若表满或插入位置非法则操作失败。 

10. 删除操作需将被删元素之后的所有元素依次前移一位，并将删除的元素值通过引用参数返回，同时更新表长。  

11. 按位查找操作直接通过数组下标访问元素，时间复杂度为O(1)，体现了顺序表的随机存取优势。  

12. 按值查找需从第一个元素开始顺序扫描，逐个比较直到找到目标值，最好情况时间复杂度为O(1)，最坏和平均情况为O(n)。 
 
13. 当数据元素为结构体类型时，不能直接使用“==”运算符进行相等判断，必须逐一比较各成员变量的值是否相等。
